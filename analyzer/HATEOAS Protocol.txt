A HATEOAS REST Protocol:

The Players
	The Back-End: From the perspective of the back-end, the focus is on maintianing the integrity of the data and the state of the system.
	The API: The goal of the API is to provide the most useful bridge possible between the back-end and the client and to the extent possible, isolating them from changes in the other.
	The Client: To work within the limitations of the API and the resources that the API uses to perform actions.

The Problem:
	The back-end system has a set of states that it can be in.  Each of these states has a set of valid inputs and outputs.  Every client of the back-end system must be properly aware of both the states of the system and the valid inputs and output in order to effectively communicate with the back-end system.

	Many APIs take a minimal approach in exposing the back-end.  Merely content to enforce authentication and a repackaging of the data structures from the back-end into JSON, XML, or some other format.

	On the client, developers are forced to manually recreate a state engine compatible with the back-end and then trying to show-horn that into an attractive interface.  This forces the client to be tightly coupled to both the API and the behavior of the server.

The Goal:
	To propose a method to reasonably decouple apriori knowledge of the server from the client though a API bridge layer.  This approach isn't new.  It is advocated in the HATEOAS philosophy and piggy-backs on the concept of hypertext links defining the flow through a document.  From what I've seen in researching the topic, a descriptive approach has not yet been put forth that is clean, consise, consistent, and practical.  That is turning the HATEOAS philosophy into a standardized implementation that allows a client to successfully interact with and navigate the states of the server without apriori knowledge.

What a successful implementation would include:
	Discovery: There should be a starting point for the application that exposes all of the starting points to the application.  From each of these initial states, all other valid states should be discoverable.
	Interogation: The ability to discover what fields to include in a resource when submitting it to the server.
	Typing: An ability to discover the typing of the fields for a resource and the constraints on those fields.
	Practicality: Providing a standard set of tools to allow the protocol to stand on its own.  CRUD operations are neccessary, but not sufficient.


 interacting with  attempt to manually recreate and enforce a valid state for the back-end in the client.  This tightly couples the clients written for the API to changes made in the back-end.  We perform a large amount of custom development on client because, unlike HTML, most REST APIs don't tell a client how to get from one state to another.

In a REST API the basic elements that we are interested in dealing with are the resources returned by the endpoints and valid subsequent actions on those resources.
This resource represents a view of the back-end object, but does not have to reveal the entire object.  Likewise, while the resource returned to the client must be deterministic it does not have to be fixed.  As long as the server is able to properly maintain its state, the representation of the objects should be allowed to vary.  Using this approach, it frees the API developer to present the client with a valid and appropriate set of fields in the returned object.  If the underlying resource contains additional fields that were not returned, they can be optionally included in the response through hints.

Singular vs Plural:
To provide a balance between consistency, granularity, and robustness I propose using a pre-determined mix of both singular and plural.

The following shows how to handle a sample resource named project:

+----------+----------------+--------+----------------------+--------------------------------------+-----------------------+--------------------+
| Plurality| Action         | Method | Sample URI           | Description                          | Success Response Code | Response Body      |
+----------+----------------+--------+----------------------+--------------------------------------+-----------------------+--------------------+
| Plural   | Search         | POST   | /projects            | performs a filtered/paginated search | 200 Ok                | Resource           |
| Plural   | Get All        | GET    | /projects            | gets all projects                    | 200 OK                | Resource           |
| Singular | Retrieve Blank | GET    | /project             | gets an empty project                | 200 Ok                | Empty Resource     |
| Singular | Create         | POST   | /project             | create new project                   | 201 Created           | Created Resource   |
| Singular | Retrieve       | GET    | /project/#           | gets a specific project              | 200 Ok                | Resource           |
| Singular | Update         | PUT    | /project/#           | update an existing project           | 200 Ok                | Updated Resource   |
| Singular | Delete         | DELETE | /project/#           | delete project                       | 204 No Content        | N/A                |
| Singular | Sample Action  | POST   | /project_validator/# | validates a project                  | 200 Ok                | Resource           |
+----------+----------------+--------+----------------------+--------------------------------------+-----------------------+--------------------+

+----------------------------+----------------------------------+---------------+
| Error Codes                | Description                      | Response Body |
+----------------------------+----------------------------------+---------------+
| 400 Bad Request            | Malformed request                | Error Message |
| 401 Unauthorized           | Resource requires authentication | Error Message |
| 403 Forbidden              | Authentication failure           | Error Message |
| 404 Not Found              | Resource not found               | Error Message |
| 415 Unsupported Media Type | Unsupported Mime Type            | Error Message |
| 500 Server Error           | Internal Server Error            | Error Message |
+----------------------------+----------------------------------+---------------+

(JSON Object Format):
{
	simple_field: "field value",
	simple_array: ["array_index1", "array_index2", ..., "array_indexN"],
	child_object: (JSON Object Format),
	child_object_array: [(JSON Object Format), (JSON Object Format)],
	links: {
		create:    { method: "POST",   uri: "some uri", label: "text"}, // to create this resource
		retrieve:  { method: "GET",    uri: "some uri", label: "text"}, // to retrieve this resource
		update:    { method: "PUT",    uri: "some uri", label: "text"}, // the update url for this resource
		delete:    { method: "DELETE", uri: "some uri", label: "text"}, // the uri to delete this resource
		action1:   { method: "POST",   uri: "some uri", label: "text"}, // actions are used to perform operations beyond CRUD on the resource
		action2:   { method: "POST",   uri: "some uri", label: "text"}, // actions are used to perform operations beyond CRUD on the resource
		actionN:   { method: "POST",   uri: "some uri", label: "text"}, // actions are used to perform operations beyond CRUD on the resource
	}
}

JSON Descriptor Object {
	fields [
		field1 { label: "text", type: "[String, Integer, Decimal, Date, Datetime]", min_length: "number", max_length: "number" },
		field2 { label: "text", type: "[String, Integer, Decimal, Date, Datetime]", min_length: "number", max_length: "number" },
		...
		fieldN { label: "text", type: "[String, Integer, Decimal, Date, Datetime]", min_length: "number", max_length: "number" },
	]
}

 The API endpoints defines how we can interact with those resources.  A resource does not necessarily have to reveal every property that exists in the back end

{
	name: "Sample Project", // simple field
	description: "My Sample Project", // simple field
	favorite_foods: [ "ribs", "steak", "salad" ], // simple string array
	admins: { // sub-objects with their own REST WS endpoints
		links: {
			create: { method: "POST", uri: "some uri"}, // to create this resource
			create: { method: "POST", uri: "some uri"}, // to create this resource
		}
		elements: [
			{
				type: "Mobile",
				phone_number: "123-456-7890",
				links: { // first provide applicable standard crud operations, then custom actions
					retrieve: { method: "GET", uri: "some uri"}, // to retrieve this resource
					update: { method: "PUT", uri: "some uri"}, // the update url for this resource
					delete: { method: "DELETE", uri: "some uri"}, // the uri to delete this resource
					send_text: { method: "POST", uri: "some uri"}
				}
			},
			{
			}
		]
	}
}

Outstanding questions:
	How is the best way to tie related information together in the action links?  For example, if looking at a loan resource how do you link to a create payment resouce referencing the loan you are currently viewing?  Relevant data might be passing in the loan id.  Without the encapsulated knowledge that one or more fields for one resource are tied to the other linked resource, you are falling back on out of band information...  Options include creating a GET endpoint that returns a prepopulated object, adding a hint to prepopulate fields in the returned object for that resource on the client side, passing in a query string on the URI for the server to prepopulate fields in the returned object.